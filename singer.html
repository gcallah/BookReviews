<!DOCTYPE html>
<html>
    <head>
        <link href="style.css" rel="stylesheet" type="text/css"/>
        <title>
            Practical C++ Design: From Programming to Architecture
        </title>
    </head>

    <body>
        <h1>
            Practical C++ Design: From Programming to Architecture
        </h1>
            <h3>
                <i>
                    Practical C++ Design:
                    From Programming to Architecture
                </i>
                Singer, Adam B.
                Apress, New York, 2017.
            </h3>

            <p>
            CSS Terms: D.2 Software Engineering [PRIMARY], D.1 Programming
            Techniques
            </p>

            <p>
            It is unfortunate for Singer that not long before reviewing his
            book, I taught a class in C++ using Bjarne Stroustrup's 
            book <i>Programming: Principles and Practices Using C++</i>.
            Stroustrup, in four chapters (out of 26) has the reader
            build a small calculator including separate lexical
            analysis, recursive-descent parsing, variables, and more.
            I thought <i>Practical C++ Design</i> would be a great
            follow-up: I would surely pick up ways to extend the
            calculator I had built, following Stroustrup, from
            Singer. But to my surprise, Singer takes a whole book to
            design a calculator in several ways less fully realized than
            Stroustrup's: there are no variables, for instance, and no
            grammar-driven parser.
            </p>

            <p>
            To be fair to Singer, however, he does include features Stroustrup
            does not, such as a complete separation of his calculator engine
            from the user interface, which enables him to create two-faced
            calculator that can appear on the command line or in a GUI.
            He also shows how to implement a plug-in feature to extend the
            calculator, also absent in Stroustrup's program.
            And Singer does an excellent job explaining what design patterns
            he employs to create each of his calculator's features.
            </p>

            <p>
            The book begins, quite properly, by setting out the "requirements"
            for the calculator to be built. Since Singer at the start of the
            project is not building his program for anyone else, the
            requirements are like a note from Singer the user to Singer the
            programmer. Nevertheless, even on a project no one but the coder 
            himself will ever use, explicitly stating what is required of it
            may be useful. And here, this serves an additional didactic
            purpose.
            </p>

            <p>
            But here as well there is a fly in the ointment: one of the 
            "requirements" of the project is that the calculator use
            Reverse Polish Notation (RPN). Singer assures us that if we just
            get used to RPN, we'll like it. But several hundred years of
            mathematical practice suggest that human beings most easily
            understand mathematical expressions when they are written in the
            "normal" way, i.e., using infix notation. RPN was created to ease
            the burden on programmers and machines, not on users. With 
            fast CPUs accessing gigabytes of RAM, programmed by engineers who
            can stand upon decades of experience creating parsers, perhaps we
            ought to lay this vestige of the days of 4K core memories to rest? 
            </p>

            <p>
            After laying out the user requirements, Singer explains his design
            requirements. The difference between the two is that the user
            requirements delineate what the software ought to <i>do</i>,
            while the design requirements describe how it ought to be
            constructed, in order to do what it needs to do. The chief design 
            virtues Singer wants to illustrate are modularity, encapsulation,
            cohesion, and low coupling. These are familiar enough that I think
            there is no need to expound upon them here.
            </p>

            <p>
            Singer next explains the idea of patterns, and differentiates
            architectural patterns (by which he means the architecture of
            a computer system, and not the actual architectural patterns
            that Christopher Alexander described) and design patterns. 
            Per his distinction, design patterns apply primarily to a class or
            a small group of classes, while architectural patterns address
            entire information processing systems.
            </p>

            <p>
                The first of the two architectural patterns 
                that Singer examines is
                multi-tiering, separating the top-tier user interface,
                which can comunicate only with the middle, logic tier,
                and a bottom-level data tier, which again can communicate
                only with the middle tier.
                The second pattern is model-view-controller (MVC).
                Singer describes the major difference between 
            </p>

            <p>
                In the rest of his progress towards a working calculator,
                Singer addresses many more important design ideas, including
                the "pimpl idiom" (a private pointer that keeps a classes
                private implementation out of a header file), the Observer
                pattern (for waiting on events), the Command pattern (for
                implementing commands like "add" and "subtract")
                He discusses modern C++ features such as unique and shared
                pointers, the `final` keyword, and uniform initialization,
                and shows how they are superior to older styles used
                in similar situations. He stresses the importance of early
                testing, but does not go into depth on the topic.
            </p>

            <p>
                Due to Singer's attention to modular design and his wise use 
                of design patterns, the `main()` function of the calculator
                can set up, assemble, and execute the calculator in just six
                lines. As he notes, the most important aspect of such a design
                is that a new programmer coming along to maintain the program
                can easily grasp its overall structure in just a brief perusal
                of `main.cpp`.
            </p>

            <p>
                This is an excellent book, clearly demonstrating how to employ
                many OOP design patterns to create a maintainable, working 
                program. I only wish Singer had taken note of his illustrious
                predecessor's work in the same domain, as he could have shown
                us how to extend Stroustrup's calculator, instead of starting
                over and thus omitting key features that Stroustrup had already
                shown us how to build.
            </p>

    </body>
</html>
