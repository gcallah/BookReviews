<!DOCTYPE html>
<html>
    <head>
        <link href="style.css" rel="stylesheet" type="text/css"/>
        <title>
            Practical C++ Design: From Programming to Architecture
        </title>
    </head>

    <body>
        <h1>
            Practical C++ Design: From Programming to Architecture
        </h1>
            <h3>
                <i>
                    Practical C++ Design:
                    From Programming to Architecture
                </i>
                Singer, Adam B.
                Apress, New York, 2017.
            </h3>

            <p>
            CSS Terms: D.2 Software Engineering [PRIMARY], D.1 Programming
            Techniques
            </p>

            <p>
            It is unfortunate for Singer that not long before reviewing his
            book, I taught a class in C++ using Bjarne Stroustrup's 
            book <i>Programming: Principles and Practices Using C++</i>.
            Stroustrup, in four chapters (out of 26) has the reader
            build a small calculator including separate lexical
            analysis, recursive-descent parsing, variables, and more.
            I thought <i>Practical C++ Design</i> would be a great
            follow-up: I would surely pick up ways to extend the
            calculator I had built, following Stroustrup, from
            Singer. But to my surprise, Singer takes a whole book to
            design a calculator in several ways less fully realized than
            Stroustrup's: there are no variables, for instance, and no
            grammar-driven parser.
            </p>

            <p>
            To be fair to Singer, however, he does include features Stroustrup
            does not, such as a complete separation of his calculator engine
            from the user interface, which enables him to create two-faced
            calculator that can appear on the command line or in a GUI.
            And he does an excellent job explaining what design patterns
            he employs to create each of his calculator's features.
            </p>

            <p>
            The book begins, quite properly, by setting out the "requirements"
            for the calculator to be built. Since Singer at the start of the
            project is not building his program for anyone else, the
            requirements are like a note from Singer the user to Singer the
            programmer. Nevertheless, even on a project no one but the coder 
            himself will ever use, explicitly stating what is required of it
            may be useful. And here, this serves an additional didactic
            purpose.
            </p>

            <p>
            But here as well there is a fly in the ointment: one of the 
            "requirements" of the project is that the calculator use
            Reverse Polish Notation (RPN). Singer assures us that if we just
            get used to RPN, we'll like it. But several hundred years of
            mathematical practice suggest that human beings most easily
            understand mathematical expression when they are expressed in the
            "normal" way, i.e., using infix notation. RPN was created to ease
            the burden on programmers and machines, not on users. With 
            fast CPUs accessing gigabytes of RAM, programmed by engineers who
            can stand upon decades of experience creating parsers, perhaps we
            ought to lay this vestige of the days of 4K core memories to rest? 
            </p>

    </body>
</html>
